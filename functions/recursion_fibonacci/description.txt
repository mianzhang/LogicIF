INPUTS: Alright, so you’re starting with just one number, which we’ll call n. It’s assumed to be a whole number zero or higher. That’s the only thing you have to feed in. Everything else—like counters and helper structures—will be created as you go. One special thing to know right away: we’ll compute something called a threshold by taking the square root of n, rounding it down to the nearest whole number, and if that ever comes out to zero we’ll bump it up to one. That threshold tells us how far to do a simple build-up before switching gears to a faster method. 

LOGICS: Step 1: Set three counters to zero in your head or on paper: dp_steps, matrix_mults, binary_steps. These will track how many little operations you perform. Step 2: Immediately check if n is less than 2. If n is 0 or 1, you can skip everything else and just say the answer is n, with all three counters staying at zero. Step 3: Otherwise, compute threshold by taking the square root of n, chopping off any decimals, and then if that gives you 0 set threshold to 1. Step 4: Build a list called cache of size (threshold + 1). Initialize cache[0] = 0 and cache[1] = 1. Step 5: Now, starting from i = 2 and going up through i = threshold, do this for each i: add the two previous values, so cache[i] = cache[i – 1] + cache[i – 2], and then immediately increase dp_steps by one. That’s your simple dynamic programming phase. Step 6: Next, get ready to do matrix exponentiation. Whenever you multiply two 2×2 matrices, you’ll do it in the normal way: multiply and add each row-column pair, and every time you do that full multiplication you add one to matrix_mults. Step 7: To raise a matrix to a power exp, follow these rules—and each time you enter that routine, bump binary_steps by one: if exp equals 1, just return the base Fibonacci matrix [[1,1],[1,0]]. If exp is even, first recursively compute mat_pow(exp/2), then multiply that matrix by itself (counting one matrix_mult). If exp is odd and bigger than 1, first recursively compute mat_pow(exp – 1), then multiply that result by the base matrix (again counting one matrix_mult). Step 8: Now decide which route to take based on n and threshold: if n is at most threshold, your final result is simply cache[n]. Otherwise, compute exp = n – threshold, call the matrix-power routine on exp to get a matrix m, and then compute result = m[0][0] * cache[threshold] + m[0][1] * cache[threshold – 1]. That multiplication and addition here are just plain arithmetic steps and don’t change any of the three counters. Step 9: You’re done with the logic—return the result number and the three counters dp_steps, matrix_mults, binary_steps. 

OUTPUTS: When you finish, you’ll have two things: the Fibonacci number at position n, and a little report of how much work you did. The report is a mapping with three entries: 'dp_steps' telling you how many additions you did in the build-up loop, 'matrix_mults' telling you how many times you multiplied two matrices, and 'binary_steps' telling you how many times you entered the matrix-power routine. Together they look like {'dp_steps': X, 'matrix_mults': Y, 'binary_steps': Z}. That’s exactly what the function would hand back.