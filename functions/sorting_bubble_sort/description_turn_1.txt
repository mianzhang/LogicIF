INPUTS: Okay, let’s imagine you have a simple list of numbers in front of you—say, any bunch of numeric values written in a row. We’ll call that your array. There could be zero elements, one element, or many elements. There’s no hidden structure—just a sequence of values you want to sort and also count how many times you assign things to buckets, how many comparisons you make in the insertion sort phase, and how many swaps you perform during that same phase. That’s all we start with: a flat list of numbers, nothing fancy beyond that. 

LOGICS: First off, count how many items are in your list and keep that as n. At the same time, set up three counters on a clean sheet: one labeled bucket_assignments, one labeled insertion_comparisons, and one labeled insertion_swaps. Write zeros next to each of those. Next, check if your list has one or zero items. If it does, you’re done—you simply return the very same list and report those zeros.   

If there are two or more items, we move on. Now pick the first number in your list and call it both your minimum (mn) and your maximum (mx) for now. Then, one by one, scan through every number in the list: if the current number is less than your mn, overwrite mn with that number; if it’s greater than your mx, overwrite mx. By the time you’ve looked at all the numbers, you’ll have the true mn and mx.   

Next, compute the overall range by subtracting mn from mx; write that value down as rng. Then figure out how many buckets to use: take the square root of n, drop any fraction so you have an integer, and if that integer ever ends up zero, just treat it like one. Call that count k.   

Now get k empty buckets ready—just draw k empty boxes on your paper or imagine k labeled compartments. Then, for each number x in your original list, do this: subtract mn from x, divide that by (rng + 1) to normalize it into a fraction between 0 and just under 1, then multiply by k. Take just the whole-number part of that result (ignore anything after the decimal) and call it idx, which will be somewhere from zero up to k−1. Then drop x into bucket number idx. Each time you put a number into a bucket, add one to bucket_assignments.   

Once every number is in a bucket, prepare another blank list called result. You’re going to empty each bucket back into result, but first you’ll sort within each bucket by hand. For each bucket in turn, look at its contents. If a bucket has zero or one item, there’s nothing to do—just move on. If it has two or more, do an insertion sort: start at the second item (position 1) and call that value key. Also set j = that position index. Now, while j is greater than zero, do this sequence: increment insertion_comparisons by one; compare the value immediately before your j-th slot (that’s b[j−1]) with key. If b[j−1] is larger than key, move b[j−1] forward into position j (that’s like shifting it up), increment insertion_swaps by one, then decrease j by one and repeat the while loop. If b[j−1] is not larger than key, stop the while loop. When you stop, write key into position j. That finishes placing that key. Then move to the next index in the bucket and repeat: pick the new key, set j, compare and shift, count comparisons, count swaps, and so on until the bucket is sorted.   

As soon as one bucket is fully sorted, take its items in order and append them to your result list (just write them down at the end). Then go to the next bucket and do the same: sort it by insertion sort with those same counts, then append. Keep track the whole time of how many comparisons and swaps you do in total across all buckets.   

When you finish the last bucket, you’ll have one long list in result. That’s your sorted output along with the three tallies you’ve kept—bucket_assignments, insertion_comparisons, and insertion_swaps—each reflecting exactly what the code would have done. 

OUTPUTS: In the end, you’ll hold in your hands a fully sorted list of all the original numbers. Alongside it, you’ll have three numbers: how many times you assigned an element into a bucket, how many comparisons you made during all of the insertion-sort steps, and how many individual shifts (or swaps) you performed in those same steps. That mirrors exactly the function’s return: first the sorted array, and then a little report showing those three counters.